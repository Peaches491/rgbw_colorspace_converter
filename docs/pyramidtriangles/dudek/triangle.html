<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyramidtriangles.dudek.triangle API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyramidtriangles.dudek.triangle</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import defaultdict
from logging import getLogger
from random import choice

from .HelperFunctions import distance, ROTATE_CLOCK, ROTATE_COUNTER, ROTATE_COORD_CLOCK
from ..grid import Coordinate

logger = getLogger(__name__)


&#34;&#34;&#34;
Model to communicate with a Triangle simulator over a TCP socket

Parameters for each Triangle: (X,Y), corner, direction
Corner: connector attachment is &#39;L&#39; = Left, &#39;R&#39; = Right, &#39;C&#39; = Center
Direction: As viewed from corner, lights go &#39;L&#39; = Left, &#39;R&#39; = Right
Processing file needs to be similarly adjusted
&#34;&#34;&#34;
NUM_BIG_TRI = 6

BIG_COORD = [((0, 0), &#39;L&#39;, &#39;L&#39;),
             ((1, 1), &#39;L&#39;, &#39;L&#39;),
             ((2, 0), &#39;L&#39;, &#39;L&#39;),
             ((4, 0), &#39;L&#39;, &#39;L&#39;),
             ((5, 1), &#39;L&#39;, &#39;L&#39;),
             ((6, 0), &#39;L&#39;, &#39;L&#39;)]

TRI_GEN = 12    # Size of Big Triangles - Fixed at 12


def load_triangles(model):
    return Triangle(model)


class Triangle:
    &#34;&#34;&#34;
    Triangle coordinates are stored in a hash table.
    Keys are (x,y) coordinate tuples
    Values are (strip, pixel) tuples, sometimes more than one.

    Frames implemented to shorten messages:
    Send only the pixels that change color
    Frames are hash tables where keys are (x,y) coordinates
    and values are (r,g,b) colors
    &#34;&#34;&#34;
    def __init__(self, model):
        self.model = model
        self.cellmap = self.add_strips(BIG_COORD)
        self.curr_frame = {}
        self.next_frame = {}
        self.init_frames()

    def __repr__(self):
        return &#34;Triangles(%s)&#34; % self.model

    def all_cells(self):
        &#34;&#34;&#34;Return the list of all valid coords&#34;&#34;&#34;
        return self.cellmap.keys()

    def cell_exists(self, coord):
        &#34;&#34;&#34;Return boolean of whether cell exists&#34;&#34;&#34;
        return coord in self.cellmap

    def set_cell(self, coord, color):
        if self.cell_exists(coord):
            self.next_frame[coord] = color

    def set_cells(self, coords, color):
        for coord in coords:
            self.set_cell(coord, color)

    def set_all_cells(self, color):
        self.set_cells(self.all_cells(), color)

    def black_cell(self, coord):
        self.set_cell(coord, (0, 0, 0))

    def black_cells(self, coords):
        self.set_cells(coords, (0, 0, 0))

    def black_all_cells(self):
        self.set_all_cells((0, 0, 0))

    def clear(self):
        self.force_frame()
        self.black_all_cells()
        self.go()

    def go(self, fract=1):
        self.send_frame(fract)
        self.model.go(fract)
        self.update_frame()

    def send_delay(self, delay):
        self.model.send_delay(delay)

    def update_frame(self):
        for coord in self.next_frame:
            self.curr_frame[coord] = self.next_frame[coord]

    def send_frame(self, fract=1):
        for coord, color in self.next_frame.items():
            if fract != 1 or (coord in self.curr_frame and self.curr_frame[coord] != color):  # Has the color changed?
                self.model.set(Coordinate(*self.cellmap[coord]), color)

    def force_frame(self):
        for coord in self.curr_frame:
            self.curr_frame[coord] = (-1, -1, -1)  # Force update

    def init_frames(self):
        for coord in self.cellmap:
            self.curr_frame[coord] = (0, 0, 0)
            self.next_frame[coord] = (0, 0, 0)

    def get_rand_cell(self):
        return choice(self.all_cells())

    def get_strip_from_coord(self, coord):
        &#34;&#34;&#34;pulls the first strip that fits a coordinate&#34;&#34;&#34;
        choices = self.cellmap[coord]
        (strip, fix) = choices[0]
        return strip

    def add_strips(self, coord_table):
        cellmap = defaultdict(list)
        for strip, (big_coord, corner, direction) in enumerate(coord_table):
            cellmap = self.add_strip(cellmap, strip, big_coord, corner, direction)
        return cellmap

    def add_strip(self, cellmap, strip, big_coord, corner, direction):
        &#34;&#34;&#34;Stuff the cellmap with a Triangle strip, going row by column&#34;&#34;&#34;
        (x_offset, y_offset) = big_coord
        x_offset *= TRI_GEN
        y_offset *= TRI_GEN

        if not point_up(big_coord):
            y_offset += (TRI_GEN - 1)

        for y in range(TRI_GEN):
            for x in range(row_width(y)):
                xcoord = x_offset + x + y
                ycoord = y_offset + y if point_up(big_coord) else y_offset - y
                coord = (xcoord, ycoord)
                fix = self.calc_fix(coord, big_coord, corner, direction)
                cellmap[coord].append((strip, fix))

        return cellmap

    def calc_fix(self, coord, big_coord, corner, direction):
        &#34;&#34;&#34;This heavy lifter function converts coordinates in fixtures&#34;&#34;&#34;
        (x, y) = coord
        (big_x, big_y) = big_coord

        x -= (big_x * TRI_GEN)    # Remove big-grid offsets
        y -= (big_y * TRI_GEN)    # Remove big-grid offsets

        # Fix downward pointing grids
        if not point_up(big_coord):    # odd = pointing down
            y = TRI_GEN - y - 1
            direction = &#39;R&#39; if direction == &#39;L&#39; else &#39;L&#39;  # Swap the light direction: L -&gt; R and R -&gt; L

        rowflip = 1 if direction == &#39;R&#39; else 0  # Left-right direction of wiring

        # y row coordinate first. We&#39;re building up LEDs one row at a time.
        fix = 0
        for row in range(y):
            fix += row_width(row)

        # add x column coordinate. Even rows serpentine back
        if y % 2 == rowflip:    # even
            fix += (row_width(y) - (x-y) - 1)
        else:   # odd
            fix += (x-y)

        # Coordinate transformation depending on how the Triangle is hung
        if corner == &#39;C&#39;:
            return ROTATE_CLOCK[fix]
        elif corner == &#39;R&#39;:
            if direction == &#39;L&#39;:
                return fix
            else:
                return ROTATE_COUNTER[fix]

        else:
            if direction == &#39;L&#39;:
                return ROTATE_COUNTER[fix]
            else:
                return fix

    def get_row(self, row):
        &#34;&#34;&#34;Return all (x,y) coordinates on a row (y)
           Terrible hack here because not all keys are well-defined tuples&#34;&#34;&#34;
        return [(coord[0], coord[1]) for coord in self.all_cells() if isinstance(coord, tuple) and row == coord[1]]

    def is_on_board(self, coord):
        &#34;&#34;&#34;Return true if coordinate is between min and max of that row&#34;&#34;&#34;
        (x, y) = coord
        row_cells = self.get_row(y)

        if not row_cells:
            return False

        row_xs = [row_x for (row_x, row_y) in row_cells]
        min_x, max_x = min(row_xs), max(row_xs)

        return min_x &lt;= x &lt;= max_x

    def six_mirror(self, coord):
        &#34;&#34;&#34;Return the six-fold mirror coordinates&#34;&#34;&#34;
        mirrors = sum([[cell, vert_mirror(cell)] for cell in self.mirror_coords(coord)], [])
        return mirrors

    def mirror_coords(self, coord):
        &#34;&#34;&#34;Return the coordinate with its two mirror coordinates&#34;&#34;&#34;
        if not self.cell_exists(coord):
            return [coord] * 3  # Don&#39;t mirror
        return [coord, self.rotate_left(coord), self.rotate_right(coord)]

    def rotate_right(self, coord):
        &#34;&#34;&#34;Rotates a coord right in its triangle space&#34;&#34;&#34;
        return self.rotate_left(self.rotate_left(coord))

    def rotate_left(self, coord):
        &#34;&#34;&#34;Rotates a coord left in its triangle space&#34;&#34;&#34;
        strip = self.get_strip_from_coord(coord)
        reduced_coord = reduce_coord(coord, strip)
        rotated_coord = ROTATE_COORD_CLOCK[reduced_coord]
        expanded_coord = expand_coord(rotated_coord, strip)
        #print coord, reduced_coord, rotated_coord, expanded_coord
        return expanded_coord


##
## tri cell primitives
##
def point_up(coord):
    (x, y) = coord
    return (x+y) % 2 == 0


def get_big_coord(strip):
    ((big_x, big_y), corner, direction) = BIG_COORD[strip]
    return big_x, big_y


def row_width(row):
    return ((TRI_GEN - row - 1) * 2) + 1


def vert_mirror(coord):
    &#34;&#34;&#34;Return the vertical mirror&#34;&#34;&#34;
    (x, y) = coord
    return row_width(y) - x - 1, y


def min_max_row():
    &#34;&#34;&#34;Return the (minimum, maximum) row (y) values&#34;&#34;&#34;
    big_ys = [big_y for ((big_x, big_y), corner, direction) in BIG_COORD]
    min_y, max_y = min(big_ys), max(big_ys)

    return min_y * TRI_GEN, (max_y * TRI_GEN) + (TRI_GEN - 1)


def min_max_column():
    &#34;&#34;&#34;Return the (minimum, maximum) column (x) values&#34;&#34;&#34;
    big_xs = [big_x for ((big_x, big_y), corner, direction) in BIG_COORD]
    min_x, max_x = min(big_xs), max(big_xs)

    return min_x * TRI_GEN, (max_x + 2) * TRI_GEN


def get_base(strip):
    (big_x, big_y) = get_big_coord(strip)
    return big_x * TRI_GEN, big_y * TRI_GEN


def get_all_func(get_func):
    &#34;&#34;&#34;
    Iterator over all Triangles
    Function must return a list of coordinates
    &#34;&#34;&#34;
    return sum([get_func(tri) for tri in range(NUM_BIG_TRI)], [])


def reduce_coord(coord, strip=0):
    &#34;&#34;&#34;Reduces a coordinate to (0,0) space&#34;&#34;&#34;
    (big_x, big_y) = get_big_coord(strip)
    (x, y) = coord

    x -= big_x * TRI_GEN
    y -= big_y * TRI_GEN

    if not point_up(get_big_coord(strip)):
        y = TRI_GEN - 1 - y

    return x, y


def expand_coord(coord, strip=0):
    &#34;&#34;&#34;Expands a reduced coordinate back to its big-tri space&#34;&#34;&#34;
    (big_x, big_y) = get_big_coord(strip)
    (x, y) = coord

    if not point_up(get_big_coord(strip)):
        y = TRI_GEN - 1 - y

    x += big_x * TRI_GEN
    y += big_y * TRI_GEN

    return x, y


def center(strip=0):
    &#34;&#34;&#34;Return a Triangle&#39;s center coordinate. Handles point-down triangles too&#34;&#34;&#34;
    coeff = 0.4 if point_up(get_big_coord(strip)) else 0.6
    (x, y) = get_base(strip)
    return x + TRI_GEN - 1, y + int(coeff * TRI_GEN)


def all_centers():
    return [center(strip) for strip in range(NUM_BIG_TRI)]


def corners(strip=0):
    &#34;&#34;&#34;Return the 3 corner coordinates of a Triangle&#34;&#34;&#34;
    pad = TRI_GEN - 1
    (x, y) = get_base(strip)
    if point_up(get_big_coord(strip)):
        return [(x, y), (x+pad, y+pad), (x+pad+pad, y)]    # L,C,R
    else:
        return [(x, y+pad), (x+pad, y), (x+pad+pad, y+pad)]    # L,C,R


def all_corners():
    &#34;&#34;&#34;Return the corners of all triangles&#34;&#34;&#34;
    return get_all_func(corners)


def left_corner(strip=0):
    return corners(strip)[0]


def center_corner(strip=0):
    return corners(strip)[1]


def right_corner(strip=0):
    return corners(strip)[2]


def all_left_corners():
    return [left_corner(strip) for strip in range(NUM_BIG_TRI)]


def all_center_corners():
    return [center_corner(strip) for strip in range(NUM_BIG_TRI)]


def all_right_corners():
    return [right_corner(strip) for strip in range(NUM_BIG_TRI)]


def edge(strip=0):
    &#34;&#34;&#34;Return the edge pixel coordinates of a Triangle. Uses the 3 corners to draw each linear edge&#34;&#34;&#34;
    corns = corners(strip)
    width = row_width(0)-1

    if point_up(get_big_coord(strip)):
        return tri_in_line(corns[0], 1, width) + tri_in_line(corns[1], 5, width) + tri_in_line(corns[2], 3, width)
    else:
        return tri_in_line(corns[0], 5, width) + tri_in_line(corns[1], 1, width) + tri_in_line(corns[2], 3, width)


def all_edges():
    &#34;&#34;&#34;Return all the edge pixels&#34;&#34;&#34;
    return get_all_func(edge)


def neighbors(coord):
    &#34;&#34;&#34;Return a list of the three tris neighboring a tuple at a given coordinate&#34;&#34;&#34;
    (x, y) = coord

    if (x+y) % 2 == 0:  # Even
        _neighbors = [(1, 0), (0, -1), (-1, 0)]    # Point up
    else:
        _neighbors = [(1, 0), (0, 1), (-1, 0)]     # Point down

    return [(x+dx, y+dy) for (dx, dy) in _neighbors]


def tri_in_line(coord, direction, distance=0):
    &#34;&#34;&#34;
    Return the coord and all pixels in the direction
    along the distance
    &#34;&#34;&#34;
    cells = [coord]
    for i in range(distance):
        coord = tri_nextdoor(coord, direction)
        cells.append(coord)
    return cells


def tri_in_direction(coord, direction, distance=1):
    r&#34;&#34;&#34;
    Return the coordinates of the tri in a direction from a given tri.
    Direction is indicated by an integer
    There are 6 directions along hexagonal axes

     2  /\  1
     3 |  | 0
     4  \/  5

    &#34;&#34;&#34;
    for i in range(distance):
        coord = tri_nextdoor(coord, direction)
    return coord


def tri_nextdoor(coord, direction):
    &#34;&#34;&#34;
    Return the coordinates of the adjacent tri in the given direction
    Even (point up) and odd (point down) tri behave different
    Coordinates determined from a lookup table
    &#34;&#34;&#34;
    _evens = [(1, 0), (1, 0), (-1, 0), (-1, 0), (0, -1), (0, -1)]
    _odds  = [(1, 0), (0, 1), (0, 1), (-1, 0), (-1, 0), (1, 0)]

    (x, y) = coord

    if (x+y) % 2 == 0:  # Even
        (dx, dy) = _evens[direction % 6]
    else:
        (dx, dy) = _odds[direction % 6]

    return x+dx, y+dy


def get_rand_neighbor(coord):
    &#34;&#34;&#34;
    Return a random neighbors
    Neighbor may not be in bounds
    &#34;&#34;&#34;
    return choice(neighbors(coord))


def clock(coord, center_coord):
    &#34;&#34;&#34;Return the clockwise cell (dir + 2)&#34;&#34;&#34;
    return get_adj_cell(coord, center_coord, 2)


def counterclock(coord, center_coord):
    &#34;&#34;&#34;Return the counterclockwise cell (dir + 1)&#34;&#34;&#34;
    return get_adj_cell(coord, center_coord, 1)


def get_adj_cell(coord, center_coord, clock_pos):
    _neighbors = neighbors(coord)
    closest = near_neighbor(coord, center_coord)

    for i in range(3):
        if closest == _neighbors[i]:
            return _neighbors[(i + clock_pos) % 3]

    logger.warning(&#34;can&#39;t find a cell for %s pos&#34;, clock_pos)
    return coord


def near_neighbor(coord, center_coord):
    &#34;&#34;&#34;Return the neighbor of coord that is closest to center&#34;&#34;&#34;
    nearest = sorted(neighbors(coord), key=lambda cell: distance(cell, center_coord))[0]
    return nearest


def get_ring(center_coord, size):
    &#34;&#34;&#34;Return a list of coordinates that make up a centered ring&#34;&#34;&#34;
    size = 1 + (2 * size)  # For hex shape

    t = tri_in_direction(center_coord, 4, size)
    results = []
    for i in range(6):
        for j in range(size):
            results.append(t)
            t = tri_nextdoor(t, i)
    return results


def tri_shape(start, size):
    &#34;&#34;&#34;
    Return a list of coordinates that make up a triangle
    Triangle&#39;s left corner will be the &#39;start&#39; pixel
    start&#39;s location will determine whether triangle points up or down
    Update: rewritten so cells go around in a loop
    &#34;&#34;&#34;
    size = 2 * (size - 1)
    x = 1 if point_up(start) else 0

    return (tri_in_line(start, x, size) +
            tri_in_line(tri_in_direction(start, x, size), x+4, size) +
            tri_in_line(tri_in_direction(start, x-1, size), x+2, size))


def nested_triangles(start):
    &#34;&#34;&#34;
    Return a list of lists of coordinates,
    A list of concentric triangles with the largest first
    with each triangle centered in the middle
    Triangle&#39;s left corner will be the &#39;start&#39; pixel
    &#34;&#34;&#34;
    left_corn = start
    direction = 1 if point_up(start) else 5

    cells = []
    for size in range(TRI_GEN, 0, -3):
        cells.append(tri_shape(left_corn, size))
        left_corn = tri_in_direction(tri_in_direction(left_corn, direction, 2), 0, 2)

    return cells


def inset_triangles(start, num_triangles=TRI_GEN):
    &#34;&#34;&#34;
    Return a list of lists of coordinates,
    A list of inset triangles with the largest first
    with each triangle offset by &#39;direction&#39;
    Triangle&#39;s left corner will be the &#39;start&#39; pixel
    &#34;&#34;&#34;
    left_corn = start

    cells = []
    for size in range(num_triangles, 0, -2):
        cells.append(tri_shape(left_corn, size))
        left_corn = tri_in_direction(left_corn, 0, 2)

    return cells</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pyramidtriangles.dudek.triangle.logger"><code class="name">var <span class="ident">logger</span></code></dt>
<dd>
<div class="desc"><p>Model to communicate with a Triangle simulator over a TCP socket</p>
<p>Parameters for each Triangle: (X,Y), corner, direction
Corner: connector attachment is 'L' = Left, 'R' = Right, 'C' = Center
Direction: As viewed from corner, lights go 'L' = Left, 'R' = Right
Processing file needs to be similarly adjusted</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyramidtriangles.dudek.triangle.all_center_corners"><code class="name flex">
<span>def <span class="ident">all_center_corners</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_center_corners():
    return [center_corner(strip) for strip in range(NUM_BIG_TRI)]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.all_centers"><code class="name flex">
<span>def <span class="ident">all_centers</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_centers():
    return [center(strip) for strip in range(NUM_BIG_TRI)]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.all_corners"><code class="name flex">
<span>def <span class="ident">all_corners</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the corners of all triangles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_corners():
    &#34;&#34;&#34;Return the corners of all triangles&#34;&#34;&#34;
    return get_all_func(corners)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.all_edges"><code class="name flex">
<span>def <span class="ident">all_edges</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all the edge pixels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_edges():
    &#34;&#34;&#34;Return all the edge pixels&#34;&#34;&#34;
    return get_all_func(edge)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.all_left_corners"><code class="name flex">
<span>def <span class="ident">all_left_corners</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_left_corners():
    return [left_corner(strip) for strip in range(NUM_BIG_TRI)]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.all_right_corners"><code class="name flex">
<span>def <span class="ident">all_right_corners</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_right_corners():
    return [right_corner(strip) for strip in range(NUM_BIG_TRI)]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>strip=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Triangle's center coordinate. Handles point-down triangles too</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(strip=0):
    &#34;&#34;&#34;Return a Triangle&#39;s center coordinate. Handles point-down triangles too&#34;&#34;&#34;
    coeff = 0.4 if point_up(get_big_coord(strip)) else 0.6
    (x, y) = get_base(strip)
    return x + TRI_GEN - 1, y + int(coeff * TRI_GEN)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.center_corner"><code class="name flex">
<span>def <span class="ident">center_corner</span></span>(<span>strip=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_corner(strip=0):
    return corners(strip)[1]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.clock"><code class="name flex">
<span>def <span class="ident">clock</span></span>(<span>coord, center_coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the clockwise cell (dir + 2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clock(coord, center_coord):
    &#34;&#34;&#34;Return the clockwise cell (dir + 2)&#34;&#34;&#34;
    return get_adj_cell(coord, center_coord, 2)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.corners"><code class="name flex">
<span>def <span class="ident">corners</span></span>(<span>strip=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the 3 corner coordinates of a Triangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corners(strip=0):
    &#34;&#34;&#34;Return the 3 corner coordinates of a Triangle&#34;&#34;&#34;
    pad = TRI_GEN - 1
    (x, y) = get_base(strip)
    if point_up(get_big_coord(strip)):
        return [(x, y), (x+pad, y+pad), (x+pad+pad, y)]    # L,C,R
    else:
        return [(x, y+pad), (x+pad, y), (x+pad+pad, y+pad)]    # L,C,R</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.counterclock"><code class="name flex">
<span>def <span class="ident">counterclock</span></span>(<span>coord, center_coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the counterclockwise cell (dir + 1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counterclock(coord, center_coord):
    &#34;&#34;&#34;Return the counterclockwise cell (dir + 1)&#34;&#34;&#34;
    return get_adj_cell(coord, center_coord, 1)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.edge"><code class="name flex">
<span>def <span class="ident">edge</span></span>(<span>strip=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the edge pixel coordinates of a Triangle. Uses the 3 corners to draw each linear edge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge(strip=0):
    &#34;&#34;&#34;Return the edge pixel coordinates of a Triangle. Uses the 3 corners to draw each linear edge&#34;&#34;&#34;
    corns = corners(strip)
    width = row_width(0)-1

    if point_up(get_big_coord(strip)):
        return tri_in_line(corns[0], 1, width) + tri_in_line(corns[1], 5, width) + tri_in_line(corns[2], 3, width)
    else:
        return tri_in_line(corns[0], 5, width) + tri_in_line(corns[1], 1, width) + tri_in_line(corns[2], 3, width)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.expand_coord"><code class="name flex">
<span>def <span class="ident">expand_coord</span></span>(<span>coord, strip=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Expands a reduced coordinate back to its big-tri space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_coord(coord, strip=0):
    &#34;&#34;&#34;Expands a reduced coordinate back to its big-tri space&#34;&#34;&#34;
    (big_x, big_y) = get_big_coord(strip)
    (x, y) = coord

    if not point_up(get_big_coord(strip)):
        y = TRI_GEN - 1 - y

    x += big_x * TRI_GEN
    y += big_y * TRI_GEN

    return x, y</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.get_adj_cell"><code class="name flex">
<span>def <span class="ident">get_adj_cell</span></span>(<span>coord, center_coord, clock_pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_adj_cell(coord, center_coord, clock_pos):
    _neighbors = neighbors(coord)
    closest = near_neighbor(coord, center_coord)

    for i in range(3):
        if closest == _neighbors[i]:
            return _neighbors[(i + clock_pos) % 3]

    logger.warning(&#34;can&#39;t find a cell for %s pos&#34;, clock_pos)
    return coord</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.get_all_func"><code class="name flex">
<span>def <span class="ident">get_all_func</span></span>(<span>get_func)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterator over all Triangles
Function must return a list of coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_func(get_func):
    &#34;&#34;&#34;
    Iterator over all Triangles
    Function must return a list of coordinates
    &#34;&#34;&#34;
    return sum([get_func(tri) for tri in range(NUM_BIG_TRI)], [])</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.get_base"><code class="name flex">
<span>def <span class="ident">get_base</span></span>(<span>strip)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_base(strip):
    (big_x, big_y) = get_big_coord(strip)
    return big_x * TRI_GEN, big_y * TRI_GEN</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.get_big_coord"><code class="name flex">
<span>def <span class="ident">get_big_coord</span></span>(<span>strip)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_big_coord(strip):
    ((big_x, big_y), corner, direction) = BIG_COORD[strip]
    return big_x, big_y</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.get_rand_neighbor"><code class="name flex">
<span>def <span class="ident">get_rand_neighbor</span></span>(<span>coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random neighbors
Neighbor may not be in bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rand_neighbor(coord):
    &#34;&#34;&#34;
    Return a random neighbors
    Neighbor may not be in bounds
    &#34;&#34;&#34;
    return choice(neighbors(coord))</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.get_ring"><code class="name flex">
<span>def <span class="ident">get_ring</span></span>(<span>center_coord, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of coordinates that make up a centered ring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ring(center_coord, size):
    &#34;&#34;&#34;Return a list of coordinates that make up a centered ring&#34;&#34;&#34;
    size = 1 + (2 * size)  # For hex shape

    t = tri_in_direction(center_coord, 4, size)
    results = []
    for i in range(6):
        for j in range(size):
            results.append(t)
            t = tri_nextdoor(t, i)
    return results</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.inset_triangles"><code class="name flex">
<span>def <span class="ident">inset_triangles</span></span>(<span>start, num_triangles=12)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of lists of coordinates,
A list of inset triangles with the largest first
with each triangle offset by 'direction'
Triangle's left corner will be the 'start' pixel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inset_triangles(start, num_triangles=TRI_GEN):
    &#34;&#34;&#34;
    Return a list of lists of coordinates,
    A list of inset triangles with the largest first
    with each triangle offset by &#39;direction&#39;
    Triangle&#39;s left corner will be the &#39;start&#39; pixel
    &#34;&#34;&#34;
    left_corn = start

    cells = []
    for size in range(num_triangles, 0, -2):
        cells.append(tri_shape(left_corn, size))
        left_corn = tri_in_direction(left_corn, 0, 2)

    return cells</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.left_corner"><code class="name flex">
<span>def <span class="ident">left_corner</span></span>(<span>strip=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def left_corner(strip=0):
    return corners(strip)[0]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.load_triangles"><code class="name flex">
<span>def <span class="ident">load_triangles</span></span>(<span>model)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_triangles(model):
    return Triangle(model)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.min_max_column"><code class="name flex">
<span>def <span class="ident">min_max_column</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (minimum, maximum) column (x) values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_max_column():
    &#34;&#34;&#34;Return the (minimum, maximum) column (x) values&#34;&#34;&#34;
    big_xs = [big_x for ((big_x, big_y), corner, direction) in BIG_COORD]
    min_x, max_x = min(big_xs), max(big_xs)

    return min_x * TRI_GEN, (max_x + 2) * TRI_GEN</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.min_max_row"><code class="name flex">
<span>def <span class="ident">min_max_row</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (minimum, maximum) row (y) values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_max_row():
    &#34;&#34;&#34;Return the (minimum, maximum) row (y) values&#34;&#34;&#34;
    big_ys = [big_y for ((big_x, big_y), corner, direction) in BIG_COORD]
    min_y, max_y = min(big_ys), max(big_ys)

    return min_y * TRI_GEN, (max_y * TRI_GEN) + (TRI_GEN - 1)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.near_neighbor"><code class="name flex">
<span>def <span class="ident">near_neighbor</span></span>(<span>coord, center_coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the neighbor of coord that is closest to center</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def near_neighbor(coord, center_coord):
    &#34;&#34;&#34;Return the neighbor of coord that is closest to center&#34;&#34;&#34;
    nearest = sorted(neighbors(coord), key=lambda cell: distance(cell, center_coord))[0]
    return nearest</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.neighbors"><code class="name flex">
<span>def <span class="ident">neighbors</span></span>(<span>coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of the three tris neighboring a tuple at a given coordinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbors(coord):
    &#34;&#34;&#34;Return a list of the three tris neighboring a tuple at a given coordinate&#34;&#34;&#34;
    (x, y) = coord

    if (x+y) % 2 == 0:  # Even
        _neighbors = [(1, 0), (0, -1), (-1, 0)]    # Point up
    else:
        _neighbors = [(1, 0), (0, 1), (-1, 0)]     # Point down

    return [(x+dx, y+dy) for (dx, dy) in _neighbors]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.nested_triangles"><code class="name flex">
<span>def <span class="ident">nested_triangles</span></span>(<span>start)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of lists of coordinates,
A list of concentric triangles with the largest first
with each triangle centered in the middle
Triangle's left corner will be the 'start' pixel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nested_triangles(start):
    &#34;&#34;&#34;
    Return a list of lists of coordinates,
    A list of concentric triangles with the largest first
    with each triangle centered in the middle
    Triangle&#39;s left corner will be the &#39;start&#39; pixel
    &#34;&#34;&#34;
    left_corn = start
    direction = 1 if point_up(start) else 5

    cells = []
    for size in range(TRI_GEN, 0, -3):
        cells.append(tri_shape(left_corn, size))
        left_corn = tri_in_direction(tri_in_direction(left_corn, direction, 2), 0, 2)

    return cells</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.point_up"><code class="name flex">
<span>def <span class="ident">point_up</span></span>(<span>coord)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_up(coord):
    (x, y) = coord
    return (x+y) % 2 == 0</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.reduce_coord"><code class="name flex">
<span>def <span class="ident">reduce_coord</span></span>(<span>coord, strip=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduces a coordinate to (0,0) space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_coord(coord, strip=0):
    &#34;&#34;&#34;Reduces a coordinate to (0,0) space&#34;&#34;&#34;
    (big_x, big_y) = get_big_coord(strip)
    (x, y) = coord

    x -= big_x * TRI_GEN
    y -= big_y * TRI_GEN

    if not point_up(get_big_coord(strip)):
        y = TRI_GEN - 1 - y

    return x, y</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.right_corner"><code class="name flex">
<span>def <span class="ident">right_corner</span></span>(<span>strip=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def right_corner(strip=0):
    return corners(strip)[2]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.row_width"><code class="name flex">
<span>def <span class="ident">row_width</span></span>(<span>row)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def row_width(row):
    return ((TRI_GEN - row - 1) * 2) + 1</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.tri_in_direction"><code class="name flex">
<span>def <span class="ident">tri_in_direction</span></span>(<span>coord, direction, distance=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the coordinates of the tri in a direction from a given tri.
Direction is indicated by an integer
There are 6 directions along hexagonal axes</p>
<p>2
/\
1
3 |
| 0
4
\/
5</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tri_in_direction(coord, direction, distance=1):
    r&#34;&#34;&#34;
    Return the coordinates of the tri in a direction from a given tri.
    Direction is indicated by an integer
    There are 6 directions along hexagonal axes

     2  /\  1
     3 |  | 0
     4  \/  5

    &#34;&#34;&#34;
    for i in range(distance):
        coord = tri_nextdoor(coord, direction)
    return coord</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.tri_in_line"><code class="name flex">
<span>def <span class="ident">tri_in_line</span></span>(<span>coord, direction, distance=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the coord and all pixels in the direction
along the distance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tri_in_line(coord, direction, distance=0):
    &#34;&#34;&#34;
    Return the coord and all pixels in the direction
    along the distance
    &#34;&#34;&#34;
    cells = [coord]
    for i in range(distance):
        coord = tri_nextdoor(coord, direction)
        cells.append(coord)
    return cells</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.tri_nextdoor"><code class="name flex">
<span>def <span class="ident">tri_nextdoor</span></span>(<span>coord, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the coordinates of the adjacent tri in the given direction
Even (point up) and odd (point down) tri behave different
Coordinates determined from a lookup table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tri_nextdoor(coord, direction):
    &#34;&#34;&#34;
    Return the coordinates of the adjacent tri in the given direction
    Even (point up) and odd (point down) tri behave different
    Coordinates determined from a lookup table
    &#34;&#34;&#34;
    _evens = [(1, 0), (1, 0), (-1, 0), (-1, 0), (0, -1), (0, -1)]
    _odds  = [(1, 0), (0, 1), (0, 1), (-1, 0), (-1, 0), (1, 0)]

    (x, y) = coord

    if (x+y) % 2 == 0:  # Even
        (dx, dy) = _evens[direction % 6]
    else:
        (dx, dy) = _odds[direction % 6]

    return x+dx, y+dy</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.tri_shape"><code class="name flex">
<span>def <span class="ident">tri_shape</span></span>(<span>start, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of coordinates that make up a triangle
Triangle's left corner will be the 'start' pixel
start's location will determine whether triangle points up or down
Update: rewritten so cells go around in a loop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tri_shape(start, size):
    &#34;&#34;&#34;
    Return a list of coordinates that make up a triangle
    Triangle&#39;s left corner will be the &#39;start&#39; pixel
    start&#39;s location will determine whether triangle points up or down
    Update: rewritten so cells go around in a loop
    &#34;&#34;&#34;
    size = 2 * (size - 1)
    x = 1 if point_up(start) else 0

    return (tri_in_line(start, x, size) +
            tri_in_line(tri_in_direction(start, x, size), x+4, size) +
            tri_in_line(tri_in_direction(start, x-1, size), x+2, size))</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.vert_mirror"><code class="name flex">
<span>def <span class="ident">vert_mirror</span></span>(<span>coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the vertical mirror</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vert_mirror(coord):
    &#34;&#34;&#34;Return the vertical mirror&#34;&#34;&#34;
    (x, y) = coord
    return row_width(y) - x - 1, y</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyramidtriangles.dudek.triangle.Triangle"><code class="flex name class">
<span>class <span class="ident">Triangle</span></span>
<span>(</span><span>model)</span>
</code></dt>
<dd>
<div class="desc"><p>Triangle coordinates are stored in a hash table.
Keys are (x,y) coordinate tuples
Values are (strip, pixel) tuples, sometimes more than one.</p>
<p>Frames implemented to shorten messages:
Send only the pixels that change color
Frames are hash tables where keys are (x,y) coordinates
and values are (r,g,b) colors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Triangle:
    &#34;&#34;&#34;
    Triangle coordinates are stored in a hash table.
    Keys are (x,y) coordinate tuples
    Values are (strip, pixel) tuples, sometimes more than one.

    Frames implemented to shorten messages:
    Send only the pixels that change color
    Frames are hash tables where keys are (x,y) coordinates
    and values are (r,g,b) colors
    &#34;&#34;&#34;
    def __init__(self, model):
        self.model = model
        self.cellmap = self.add_strips(BIG_COORD)
        self.curr_frame = {}
        self.next_frame = {}
        self.init_frames()

    def __repr__(self):
        return &#34;Triangles(%s)&#34; % self.model

    def all_cells(self):
        &#34;&#34;&#34;Return the list of all valid coords&#34;&#34;&#34;
        return self.cellmap.keys()

    def cell_exists(self, coord):
        &#34;&#34;&#34;Return boolean of whether cell exists&#34;&#34;&#34;
        return coord in self.cellmap

    def set_cell(self, coord, color):
        if self.cell_exists(coord):
            self.next_frame[coord] = color

    def set_cells(self, coords, color):
        for coord in coords:
            self.set_cell(coord, color)

    def set_all_cells(self, color):
        self.set_cells(self.all_cells(), color)

    def black_cell(self, coord):
        self.set_cell(coord, (0, 0, 0))

    def black_cells(self, coords):
        self.set_cells(coords, (0, 0, 0))

    def black_all_cells(self):
        self.set_all_cells((0, 0, 0))

    def clear(self):
        self.force_frame()
        self.black_all_cells()
        self.go()

    def go(self, fract=1):
        self.send_frame(fract)
        self.model.go(fract)
        self.update_frame()

    def send_delay(self, delay):
        self.model.send_delay(delay)

    def update_frame(self):
        for coord in self.next_frame:
            self.curr_frame[coord] = self.next_frame[coord]

    def send_frame(self, fract=1):
        for coord, color in self.next_frame.items():
            if fract != 1 or (coord in self.curr_frame and self.curr_frame[coord] != color):  # Has the color changed?
                self.model.set(Coordinate(*self.cellmap[coord]), color)

    def force_frame(self):
        for coord in self.curr_frame:
            self.curr_frame[coord] = (-1, -1, -1)  # Force update

    def init_frames(self):
        for coord in self.cellmap:
            self.curr_frame[coord] = (0, 0, 0)
            self.next_frame[coord] = (0, 0, 0)

    def get_rand_cell(self):
        return choice(self.all_cells())

    def get_strip_from_coord(self, coord):
        &#34;&#34;&#34;pulls the first strip that fits a coordinate&#34;&#34;&#34;
        choices = self.cellmap[coord]
        (strip, fix) = choices[0]
        return strip

    def add_strips(self, coord_table):
        cellmap = defaultdict(list)
        for strip, (big_coord, corner, direction) in enumerate(coord_table):
            cellmap = self.add_strip(cellmap, strip, big_coord, corner, direction)
        return cellmap

    def add_strip(self, cellmap, strip, big_coord, corner, direction):
        &#34;&#34;&#34;Stuff the cellmap with a Triangle strip, going row by column&#34;&#34;&#34;
        (x_offset, y_offset) = big_coord
        x_offset *= TRI_GEN
        y_offset *= TRI_GEN

        if not point_up(big_coord):
            y_offset += (TRI_GEN - 1)

        for y in range(TRI_GEN):
            for x in range(row_width(y)):
                xcoord = x_offset + x + y
                ycoord = y_offset + y if point_up(big_coord) else y_offset - y
                coord = (xcoord, ycoord)
                fix = self.calc_fix(coord, big_coord, corner, direction)
                cellmap[coord].append((strip, fix))

        return cellmap

    def calc_fix(self, coord, big_coord, corner, direction):
        &#34;&#34;&#34;This heavy lifter function converts coordinates in fixtures&#34;&#34;&#34;
        (x, y) = coord
        (big_x, big_y) = big_coord

        x -= (big_x * TRI_GEN)    # Remove big-grid offsets
        y -= (big_y * TRI_GEN)    # Remove big-grid offsets

        # Fix downward pointing grids
        if not point_up(big_coord):    # odd = pointing down
            y = TRI_GEN - y - 1
            direction = &#39;R&#39; if direction == &#39;L&#39; else &#39;L&#39;  # Swap the light direction: L -&gt; R and R -&gt; L

        rowflip = 1 if direction == &#39;R&#39; else 0  # Left-right direction of wiring

        # y row coordinate first. We&#39;re building up LEDs one row at a time.
        fix = 0
        for row in range(y):
            fix += row_width(row)

        # add x column coordinate. Even rows serpentine back
        if y % 2 == rowflip:    # even
            fix += (row_width(y) - (x-y) - 1)
        else:   # odd
            fix += (x-y)

        # Coordinate transformation depending on how the Triangle is hung
        if corner == &#39;C&#39;:
            return ROTATE_CLOCK[fix]
        elif corner == &#39;R&#39;:
            if direction == &#39;L&#39;:
                return fix
            else:
                return ROTATE_COUNTER[fix]

        else:
            if direction == &#39;L&#39;:
                return ROTATE_COUNTER[fix]
            else:
                return fix

    def get_row(self, row):
        &#34;&#34;&#34;Return all (x,y) coordinates on a row (y)
           Terrible hack here because not all keys are well-defined tuples&#34;&#34;&#34;
        return [(coord[0], coord[1]) for coord in self.all_cells() if isinstance(coord, tuple) and row == coord[1]]

    def is_on_board(self, coord):
        &#34;&#34;&#34;Return true if coordinate is between min and max of that row&#34;&#34;&#34;
        (x, y) = coord
        row_cells = self.get_row(y)

        if not row_cells:
            return False

        row_xs = [row_x for (row_x, row_y) in row_cells]
        min_x, max_x = min(row_xs), max(row_xs)

        return min_x &lt;= x &lt;= max_x

    def six_mirror(self, coord):
        &#34;&#34;&#34;Return the six-fold mirror coordinates&#34;&#34;&#34;
        mirrors = sum([[cell, vert_mirror(cell)] for cell in self.mirror_coords(coord)], [])
        return mirrors

    def mirror_coords(self, coord):
        &#34;&#34;&#34;Return the coordinate with its two mirror coordinates&#34;&#34;&#34;
        if not self.cell_exists(coord):
            return [coord] * 3  # Don&#39;t mirror
        return [coord, self.rotate_left(coord), self.rotate_right(coord)]

    def rotate_right(self, coord):
        &#34;&#34;&#34;Rotates a coord right in its triangle space&#34;&#34;&#34;
        return self.rotate_left(self.rotate_left(coord))

    def rotate_left(self, coord):
        &#34;&#34;&#34;Rotates a coord left in its triangle space&#34;&#34;&#34;
        strip = self.get_strip_from_coord(coord)
        reduced_coord = reduce_coord(coord, strip)
        rotated_coord = ROTATE_COORD_CLOCK[reduced_coord]
        expanded_coord = expand_coord(rotated_coord, strip)
        #print coord, reduced_coord, rotated_coord, expanded_coord
        return expanded_coord</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyramidtriangles.dudek.triangle.Triangle.add_strip"><code class="name flex">
<span>def <span class="ident">add_strip</span></span>(<span>self, cellmap, strip, big_coord, corner, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Stuff the cellmap with a Triangle strip, going row by column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_strip(self, cellmap, strip, big_coord, corner, direction):
    &#34;&#34;&#34;Stuff the cellmap with a Triangle strip, going row by column&#34;&#34;&#34;
    (x_offset, y_offset) = big_coord
    x_offset *= TRI_GEN
    y_offset *= TRI_GEN

    if not point_up(big_coord):
        y_offset += (TRI_GEN - 1)

    for y in range(TRI_GEN):
        for x in range(row_width(y)):
            xcoord = x_offset + x + y
            ycoord = y_offset + y if point_up(big_coord) else y_offset - y
            coord = (xcoord, ycoord)
            fix = self.calc_fix(coord, big_coord, corner, direction)
            cellmap[coord].append((strip, fix))

    return cellmap</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.add_strips"><code class="name flex">
<span>def <span class="ident">add_strips</span></span>(<span>self, coord_table)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_strips(self, coord_table):
    cellmap = defaultdict(list)
    for strip, (big_coord, corner, direction) in enumerate(coord_table):
        cellmap = self.add_strip(cellmap, strip, big_coord, corner, direction)
    return cellmap</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.all_cells"><code class="name flex">
<span>def <span class="ident">all_cells</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of all valid coords</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_cells(self):
    &#34;&#34;&#34;Return the list of all valid coords&#34;&#34;&#34;
    return self.cellmap.keys()</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.black_all_cells"><code class="name flex">
<span>def <span class="ident">black_all_cells</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def black_all_cells(self):
    self.set_all_cells((0, 0, 0))</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.black_cell"><code class="name flex">
<span>def <span class="ident">black_cell</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def black_cell(self, coord):
    self.set_cell(coord, (0, 0, 0))</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.black_cells"><code class="name flex">
<span>def <span class="ident">black_cells</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def black_cells(self, coords):
    self.set_cells(coords, (0, 0, 0))</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.calc_fix"><code class="name flex">
<span>def <span class="ident">calc_fix</span></span>(<span>self, coord, big_coord, corner, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>This heavy lifter function converts coordinates in fixtures</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_fix(self, coord, big_coord, corner, direction):
    &#34;&#34;&#34;This heavy lifter function converts coordinates in fixtures&#34;&#34;&#34;
    (x, y) = coord
    (big_x, big_y) = big_coord

    x -= (big_x * TRI_GEN)    # Remove big-grid offsets
    y -= (big_y * TRI_GEN)    # Remove big-grid offsets

    # Fix downward pointing grids
    if not point_up(big_coord):    # odd = pointing down
        y = TRI_GEN - y - 1
        direction = &#39;R&#39; if direction == &#39;L&#39; else &#39;L&#39;  # Swap the light direction: L -&gt; R and R -&gt; L

    rowflip = 1 if direction == &#39;R&#39; else 0  # Left-right direction of wiring

    # y row coordinate first. We&#39;re building up LEDs one row at a time.
    fix = 0
    for row in range(y):
        fix += row_width(row)

    # add x column coordinate. Even rows serpentine back
    if y % 2 == rowflip:    # even
        fix += (row_width(y) - (x-y) - 1)
    else:   # odd
        fix += (x-y)

    # Coordinate transformation depending on how the Triangle is hung
    if corner == &#39;C&#39;:
        return ROTATE_CLOCK[fix]
    elif corner == &#39;R&#39;:
        if direction == &#39;L&#39;:
            return fix
        else:
            return ROTATE_COUNTER[fix]

    else:
        if direction == &#39;L&#39;:
            return ROTATE_COUNTER[fix]
        else:
            return fix</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.cell_exists"><code class="name flex">
<span>def <span class="ident">cell_exists</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return boolean of whether cell exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cell_exists(self, coord):
    &#34;&#34;&#34;Return boolean of whether cell exists&#34;&#34;&#34;
    return coord in self.cellmap</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self.force_frame()
    self.black_all_cells()
    self.go()</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.force_frame"><code class="name flex">
<span>def <span class="ident">force_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_frame(self):
    for coord in self.curr_frame:
        self.curr_frame[coord] = (-1, -1, -1)  # Force update</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.get_rand_cell"><code class="name flex">
<span>def <span class="ident">get_rand_cell</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rand_cell(self):
    return choice(self.all_cells())</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.get_row"><code class="name flex">
<span>def <span class="ident">get_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all (x,y) coordinates on a row (y)
Terrible hack here because not all keys are well-defined tuples</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_row(self, row):
    &#34;&#34;&#34;Return all (x,y) coordinates on a row (y)
       Terrible hack here because not all keys are well-defined tuples&#34;&#34;&#34;
    return [(coord[0], coord[1]) for coord in self.all_cells() if isinstance(coord, tuple) and row == coord[1]]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.get_strip_from_coord"><code class="name flex">
<span>def <span class="ident">get_strip_from_coord</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"><p>pulls the first strip that fits a coordinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_strip_from_coord(self, coord):
    &#34;&#34;&#34;pulls the first strip that fits a coordinate&#34;&#34;&#34;
    choices = self.cellmap[coord]
    (strip, fix) = choices[0]
    return strip</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.go"><code class="name flex">
<span>def <span class="ident">go</span></span>(<span>self, fract=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def go(self, fract=1):
    self.send_frame(fract)
    self.model.go(fract)
    self.update_frame()</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.init_frames"><code class="name flex">
<span>def <span class="ident">init_frames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_frames(self):
    for coord in self.cellmap:
        self.curr_frame[coord] = (0, 0, 0)
        self.next_frame[coord] = (0, 0, 0)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.is_on_board"><code class="name flex">
<span>def <span class="ident">is_on_board</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if coordinate is between min and max of that row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_on_board(self, coord):
    &#34;&#34;&#34;Return true if coordinate is between min and max of that row&#34;&#34;&#34;
    (x, y) = coord
    row_cells = self.get_row(y)

    if not row_cells:
        return False

    row_xs = [row_x for (row_x, row_y) in row_cells]
    min_x, max_x = min(row_xs), max(row_xs)

    return min_x &lt;= x &lt;= max_x</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.mirror_coords"><code class="name flex">
<span>def <span class="ident">mirror_coords</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the coordinate with its two mirror coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mirror_coords(self, coord):
    &#34;&#34;&#34;Return the coordinate with its two mirror coordinates&#34;&#34;&#34;
    if not self.cell_exists(coord):
        return [coord] * 3  # Don&#39;t mirror
    return [coord, self.rotate_left(coord), self.rotate_right(coord)]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.rotate_left"><code class="name flex">
<span>def <span class="ident">rotate_left</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates a coord left in its triangle space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_left(self, coord):
    &#34;&#34;&#34;Rotates a coord left in its triangle space&#34;&#34;&#34;
    strip = self.get_strip_from_coord(coord)
    reduced_coord = reduce_coord(coord, strip)
    rotated_coord = ROTATE_COORD_CLOCK[reduced_coord]
    expanded_coord = expand_coord(rotated_coord, strip)
    #print coord, reduced_coord, rotated_coord, expanded_coord
    return expanded_coord</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.rotate_right"><code class="name flex">
<span>def <span class="ident">rotate_right</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates a coord right in its triangle space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_right(self, coord):
    &#34;&#34;&#34;Rotates a coord right in its triangle space&#34;&#34;&#34;
    return self.rotate_left(self.rotate_left(coord))</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.send_delay"><code class="name flex">
<span>def <span class="ident">send_delay</span></span>(<span>self, delay)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_delay(self, delay):
    self.model.send_delay(delay)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.send_frame"><code class="name flex">
<span>def <span class="ident">send_frame</span></span>(<span>self, fract=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_frame(self, fract=1):
    for coord, color in self.next_frame.items():
        if fract != 1 or (coord in self.curr_frame and self.curr_frame[coord] != color):  # Has the color changed?
            self.model.set(Coordinate(*self.cellmap[coord]), color)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.set_all_cells"><code class="name flex">
<span>def <span class="ident">set_all_cells</span></span>(<span>self, color)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_all_cells(self, color):
    self.set_cells(self.all_cells(), color)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.set_cell"><code class="name flex">
<span>def <span class="ident">set_cell</span></span>(<span>self, coord, color)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cell(self, coord, color):
    if self.cell_exists(coord):
        self.next_frame[coord] = color</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.set_cells"><code class="name flex">
<span>def <span class="ident">set_cells</span></span>(<span>self, coords, color)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cells(self, coords, color):
    for coord in coords:
        self.set_cell(coord, color)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.six_mirror"><code class="name flex">
<span>def <span class="ident">six_mirror</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the six-fold mirror coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def six_mirror(self, coord):
    &#34;&#34;&#34;Return the six-fold mirror coordinates&#34;&#34;&#34;
    mirrors = sum([[cell, vert_mirror(cell)] for cell in self.mirror_coords(coord)], [])
    return mirrors</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.dudek.triangle.Triangle.update_frame"><code class="name flex">
<span>def <span class="ident">update_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_frame(self):
    for coord in self.next_frame:
        self.curr_frame[coord] = self.next_frame[coord]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyramidtriangles.dudek" href="index.html">pyramidtriangles.dudek</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pyramidtriangles.dudek.triangle.logger" href="#pyramidtriangles.dudek.triangle.logger">logger</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pyramidtriangles.dudek.triangle.all_center_corners" href="#pyramidtriangles.dudek.triangle.all_center_corners">all_center_corners</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.all_centers" href="#pyramidtriangles.dudek.triangle.all_centers">all_centers</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.all_corners" href="#pyramidtriangles.dudek.triangle.all_corners">all_corners</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.all_edges" href="#pyramidtriangles.dudek.triangle.all_edges">all_edges</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.all_left_corners" href="#pyramidtriangles.dudek.triangle.all_left_corners">all_left_corners</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.all_right_corners" href="#pyramidtriangles.dudek.triangle.all_right_corners">all_right_corners</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.center" href="#pyramidtriangles.dudek.triangle.center">center</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.center_corner" href="#pyramidtriangles.dudek.triangle.center_corner">center_corner</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.clock" href="#pyramidtriangles.dudek.triangle.clock">clock</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.corners" href="#pyramidtriangles.dudek.triangle.corners">corners</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.counterclock" href="#pyramidtriangles.dudek.triangle.counterclock">counterclock</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.edge" href="#pyramidtriangles.dudek.triangle.edge">edge</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.expand_coord" href="#pyramidtriangles.dudek.triangle.expand_coord">expand_coord</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.get_adj_cell" href="#pyramidtriangles.dudek.triangle.get_adj_cell">get_adj_cell</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.get_all_func" href="#pyramidtriangles.dudek.triangle.get_all_func">get_all_func</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.get_base" href="#pyramidtriangles.dudek.triangle.get_base">get_base</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.get_big_coord" href="#pyramidtriangles.dudek.triangle.get_big_coord">get_big_coord</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.get_rand_neighbor" href="#pyramidtriangles.dudek.triangle.get_rand_neighbor">get_rand_neighbor</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.get_ring" href="#pyramidtriangles.dudek.triangle.get_ring">get_ring</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.inset_triangles" href="#pyramidtriangles.dudek.triangle.inset_triangles">inset_triangles</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.left_corner" href="#pyramidtriangles.dudek.triangle.left_corner">left_corner</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.load_triangles" href="#pyramidtriangles.dudek.triangle.load_triangles">load_triangles</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.min_max_column" href="#pyramidtriangles.dudek.triangle.min_max_column">min_max_column</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.min_max_row" href="#pyramidtriangles.dudek.triangle.min_max_row">min_max_row</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.near_neighbor" href="#pyramidtriangles.dudek.triangle.near_neighbor">near_neighbor</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.neighbors" href="#pyramidtriangles.dudek.triangle.neighbors">neighbors</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.nested_triangles" href="#pyramidtriangles.dudek.triangle.nested_triangles">nested_triangles</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.point_up" href="#pyramidtriangles.dudek.triangle.point_up">point_up</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.reduce_coord" href="#pyramidtriangles.dudek.triangle.reduce_coord">reduce_coord</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.right_corner" href="#pyramidtriangles.dudek.triangle.right_corner">right_corner</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.row_width" href="#pyramidtriangles.dudek.triangle.row_width">row_width</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.tri_in_direction" href="#pyramidtriangles.dudek.triangle.tri_in_direction">tri_in_direction</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.tri_in_line" href="#pyramidtriangles.dudek.triangle.tri_in_line">tri_in_line</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.tri_nextdoor" href="#pyramidtriangles.dudek.triangle.tri_nextdoor">tri_nextdoor</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.tri_shape" href="#pyramidtriangles.dudek.triangle.tri_shape">tri_shape</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.vert_mirror" href="#pyramidtriangles.dudek.triangle.vert_mirror">vert_mirror</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyramidtriangles.dudek.triangle.Triangle" href="#pyramidtriangles.dudek.triangle.Triangle">Triangle</a></code></h4>
<ul class="">
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.add_strip" href="#pyramidtriangles.dudek.triangle.Triangle.add_strip">add_strip</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.add_strips" href="#pyramidtriangles.dudek.triangle.Triangle.add_strips">add_strips</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.all_cells" href="#pyramidtriangles.dudek.triangle.Triangle.all_cells">all_cells</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.black_all_cells" href="#pyramidtriangles.dudek.triangle.Triangle.black_all_cells">black_all_cells</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.black_cell" href="#pyramidtriangles.dudek.triangle.Triangle.black_cell">black_cell</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.black_cells" href="#pyramidtriangles.dudek.triangle.Triangle.black_cells">black_cells</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.calc_fix" href="#pyramidtriangles.dudek.triangle.Triangle.calc_fix">calc_fix</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.cell_exists" href="#pyramidtriangles.dudek.triangle.Triangle.cell_exists">cell_exists</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.clear" href="#pyramidtriangles.dudek.triangle.Triangle.clear">clear</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.force_frame" href="#pyramidtriangles.dudek.triangle.Triangle.force_frame">force_frame</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.get_rand_cell" href="#pyramidtriangles.dudek.triangle.Triangle.get_rand_cell">get_rand_cell</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.get_row" href="#pyramidtriangles.dudek.triangle.Triangle.get_row">get_row</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.get_strip_from_coord" href="#pyramidtriangles.dudek.triangle.Triangle.get_strip_from_coord">get_strip_from_coord</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.go" href="#pyramidtriangles.dudek.triangle.Triangle.go">go</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.init_frames" href="#pyramidtriangles.dudek.triangle.Triangle.init_frames">init_frames</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.is_on_board" href="#pyramidtriangles.dudek.triangle.Triangle.is_on_board">is_on_board</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.mirror_coords" href="#pyramidtriangles.dudek.triangle.Triangle.mirror_coords">mirror_coords</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.rotate_left" href="#pyramidtriangles.dudek.triangle.Triangle.rotate_left">rotate_left</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.rotate_right" href="#pyramidtriangles.dudek.triangle.Triangle.rotate_right">rotate_right</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.send_delay" href="#pyramidtriangles.dudek.triangle.Triangle.send_delay">send_delay</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.send_frame" href="#pyramidtriangles.dudek.triangle.Triangle.send_frame">send_frame</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.set_all_cells" href="#pyramidtriangles.dudek.triangle.Triangle.set_all_cells">set_all_cells</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.set_cell" href="#pyramidtriangles.dudek.triangle.Triangle.set_cell">set_cell</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.set_cells" href="#pyramidtriangles.dudek.triangle.Triangle.set_cells">set_cells</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.six_mirror" href="#pyramidtriangles.dudek.triangle.Triangle.six_mirror">six_mirror</a></code></li>
<li><code><a title="pyramidtriangles.dudek.triangle.Triangle.update_frame" href="#pyramidtriangles.dudek.triangle.Triangle.update_frame">update_frame</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>