<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyramidtriangles.grid.face API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyramidtriangles.grid.face</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from collections.abc import Iterable, MutableMapping
from itertools import chain
from typing import NamedTuple, Optional

from ..model import Model
from .cell import Cell, Orientation
from .geom import Address, Coordinate, Geometry, Universe
from .grid import Grid

PIXELS_PER_CELL: int = 8
PIXELS_IN_ROW_TURNAROUND: int = 11


class Panel(NamedTuple):
    &#34;&#34;&#34;
    Panel represents an assembled panel in the pyramid frame.

    A Face contains a set of Panels. Panel isn&#39;t expected to be used often outside of that class.
    &#34;&#34;&#34;

    geom: Geometry
    start: Address

    def cells(self, within: Geometry) -&gt; list[Cell]:
        &#34;&#34;&#34;
        Generate the panel&#39;s cells. `within` is the overall Face&#39;s geometry.
        &#34;&#34;&#34;

        cells = []
        addr = self.start

        for y in range(self.geom.rows):
            row_cells = self._cells_in_row(within, y, addr)
            cells.extend(row_cells)

            last_address = max(chain.from_iterable(
                cell.addresses for cell in row_cells))
            addr = last_address.next

        return cells

    def _cells_in_row(self, within: Geometry, y: int, start: Address) -&gt; list[Cell]:
        row = Coordinate(0, y).pos(self.geom).row

        cells = self._up_pointed_cells_in_row(within, row, y, start)
        last_up_address = cells[-1].addresses[-1]
        first_address_after_gap = last_up_address.range(
            PIXELS_IN_ROW_TURNAROUND)[-1]
        cells.extend(self._down_pointed_cells_in_row(
            within, row, y, first_address_after_gap))

        return cells

    def _up_pointed_cells_in_row(self, within: Geometry, row: int, y: int, start: Address) -&gt; list[Cell]:
        cells = []
        addr = start

        offset = int((self.geom.width - self.geom.row_length(row)) / 2)
        for i in range(row + 1):
            coord = Coordinate(self.geom.origin.x + offset + i * 2,
                               self.geom.origin.y + y)
            addrs = addr.range(PIXELS_PER_CELL)

            cells.append(Cell(coord, Orientation.POINT_UP,
                              addrs, within, real=True))

            addr = addrs[-1].next

        return cells

    def _down_pointed_cells_in_row(self, within: Geometry, row: int, y: int, start: Address) -&gt; list[Cell]:
        cells = []
        addr = start

        offset = int((self.geom.width - self.geom.row_length(row)) / 2)
        x = offset + self.geom.row_length(row) - 2
        for _ in range(row):
            coord = Coordinate(self.geom.origin.x + x, self.geom.origin.y + y)
            addrs = addr.range(PIXELS_PER_CELL)

            cells.append(Cell(coord, Orientation.POINT_DOWN,
                              addrs, within, real=True))

            x -= 2
            addr = addrs[-1].next

        return cells


# a spec for Face.build() corresponding to our real full pyramid sides
# [0] one panel at the top, [] nothing in the middle, [0, 4] positions of the bottom two panels
FULL_FACE_SPEC = [[0], [], [0, 4]]


class Face(Grid):
    &#34;&#34;&#34;
    Face is a side of the overall pyramid. It is a kind of Grid, so it can be used in the same way.

    A face is built from a specification (see `build()`).
    &#34;&#34;&#34;

    _cells: MutableMapping[Coordinate, Cell]
    panels: list[Panel]
    geom: Geometry

    @classmethod
    def build(cls,
              model: Model,
              spec: list[list[int]],
              start: Address = Address(Universe(1, 1), 4),
              rows_per_panel: int = 11) -&gt; Face:
        &#34;&#34;&#34;
        Build a Face from a panel placement spec.

        Each item the spec is a list representing a row (of panels), starting from the top.
        [[], [], []]  # represents 3 empty rows

        Adding a position to the list indicates a panel exists in that row at that position.
        [[0], [], [4]]  # represents 3 rows, panel at beginning or first row and a panel at 4th spot of 3rd row.
        &#34;&#34;&#34;

        overall_geom = Geometry(origin=Coordinate(0, 0),
                                rows=(len(spec) * rows_per_panel))
        panel_rows: list[list[Panel]] = [[] for _ in range(len(spec))]
        addr = start

        # Work row-by-row, panel-by-panel, generating all panels so we can use
        # the offset of the previous to generate the next. Later, we&#39;ll filter
        # out ones missing from the spec.
        for r in reversed(range(len(spec))):
            panel_row = panel_rows[r]
            panels_in_row = (r + 1) * 2 - 1

            if r + 1 == len(panel_rows):
                origin = Coordinate(0, 0)
            else:
                leftmost_panel_in_row_below = panel_rows[r + 1][0]
                origin = leftmost_panel_in_row_below.geom.apex.adjust(+1, +1)

            for i in range(panels_in_row):
                geom = Geometry(origin=origin, rows=rows_per_panel)
                panel = Panel(geom=geom, start=addr)

                panel_row.append(panel)

                origin = origin.adjust(x=(geom.width + 1))

                if i in spec[r]:
                    # if this panel is included, update the starting address
                    # of the next panel
                    highest_universe = max(cell.highest_universe
                                           for cell in panel.cells(overall_geom))
                    next_id = highest_universe.id + 1
                    universe = Universe(base=next_id, id=next_id)
                    addr = Address(universe, start.offset)

        # Exclude panels that aren&#39;t in the spec
        real_panels = []
        for row_spec, row_panels in zip(spec, panel_rows):
            for i, panel in enumerate(row_panels):
                if i in row_spec:
                    real_panels.append(panel)

        return Face(model, overall_geom, real_panels)

    def __init__(self, model: Model, geom: Geometry, panels: Iterable[Panel]):
        self.model = model
        self.geom = geom
        self.panels = list(panels)
        self._cells = {}

        for panel in self.panels:
            for cell in panel.cells(geom):
                self._cells[cell.coordinate] = cell

    @property
    def cells(self) -&gt; list[Cell]:
        return list(self._cells.values())

    def _cell(self, coordinate: Coordinate) -&gt; Optional[Cell]:
        return self._cells.get(coordinate)

    @property
    def next_address(self) -&gt; Address:
        lowest_addr = min(min(cell.addresses) for cell in self.cells)
        highest_universe = max(cell.highest_universe for cell in self.cells)

        next_id = highest_universe.id + 1
        return Address(Universe(next_id, next_id), lowest_addr.offset)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyramidtriangles.grid.face.Face"><code class="flex name class">
<span>class <span class="ident">Face</span></span>
<span>(</span><span>model: Model, geom: Geometry, panels: Iterable[<a title="pyramidtriangles.grid.face.Panel" href="#pyramidtriangles.grid.face.Panel">Panel</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Face is a side of the overall pyramid. It is a kind of Grid, so it can be used in the same way.</p>
<p>A face is built from a specification (see <code>build()</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Face(Grid):
    &#34;&#34;&#34;
    Face is a side of the overall pyramid. It is a kind of Grid, so it can be used in the same way.

    A face is built from a specification (see `build()`).
    &#34;&#34;&#34;

    _cells: MutableMapping[Coordinate, Cell]
    panels: list[Panel]
    geom: Geometry

    @classmethod
    def build(cls,
              model: Model,
              spec: list[list[int]],
              start: Address = Address(Universe(1, 1), 4),
              rows_per_panel: int = 11) -&gt; Face:
        &#34;&#34;&#34;
        Build a Face from a panel placement spec.

        Each item the spec is a list representing a row (of panels), starting from the top.
        [[], [], []]  # represents 3 empty rows

        Adding a position to the list indicates a panel exists in that row at that position.
        [[0], [], [4]]  # represents 3 rows, panel at beginning or first row and a panel at 4th spot of 3rd row.
        &#34;&#34;&#34;

        overall_geom = Geometry(origin=Coordinate(0, 0),
                                rows=(len(spec) * rows_per_panel))
        panel_rows: list[list[Panel]] = [[] for _ in range(len(spec))]
        addr = start

        # Work row-by-row, panel-by-panel, generating all panels so we can use
        # the offset of the previous to generate the next. Later, we&#39;ll filter
        # out ones missing from the spec.
        for r in reversed(range(len(spec))):
            panel_row = panel_rows[r]
            panels_in_row = (r + 1) * 2 - 1

            if r + 1 == len(panel_rows):
                origin = Coordinate(0, 0)
            else:
                leftmost_panel_in_row_below = panel_rows[r + 1][0]
                origin = leftmost_panel_in_row_below.geom.apex.adjust(+1, +1)

            for i in range(panels_in_row):
                geom = Geometry(origin=origin, rows=rows_per_panel)
                panel = Panel(geom=geom, start=addr)

                panel_row.append(panel)

                origin = origin.adjust(x=(geom.width + 1))

                if i in spec[r]:
                    # if this panel is included, update the starting address
                    # of the next panel
                    highest_universe = max(cell.highest_universe
                                           for cell in panel.cells(overall_geom))
                    next_id = highest_universe.id + 1
                    universe = Universe(base=next_id, id=next_id)
                    addr = Address(universe, start.offset)

        # Exclude panels that aren&#39;t in the spec
        real_panels = []
        for row_spec, row_panels in zip(spec, panel_rows):
            for i, panel in enumerate(row_panels):
                if i in row_spec:
                    real_panels.append(panel)

        return Face(model, overall_geom, real_panels)

    def __init__(self, model: Model, geom: Geometry, panels: Iterable[Panel]):
        self.model = model
        self.geom = geom
        self.panels = list(panels)
        self._cells = {}

        for panel in self.panels:
            for cell in panel.cells(geom):
                self._cells[cell.coordinate] = cell

    @property
    def cells(self) -&gt; list[Cell]:
        return list(self._cells.values())

    def _cell(self, coordinate: Coordinate) -&gt; Optional[Cell]:
        return self._cells.get(coordinate)

    @property
    def next_address(self) -&gt; Address:
        lowest_addr = min(min(cell.addresses) for cell in self.cells)
        highest_universe = max(cell.highest_universe for cell in self.cells)

        next_id = highest_universe.id + 1
        return Address(Universe(next_id, next_id), lowest_addr.offset)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyramidtriangles.grid.grid.Grid" href="grid.html#pyramidtriangles.grid.grid.Grid">Grid</a></li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyramidtriangles.grid.face.Face.geom"><code class="name">var <span class="ident">geom</span> : <a title="pyramidtriangles.grid.geom.Geometry" href="geom.html#pyramidtriangles.grid.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyramidtriangles.grid.face.Face.panels"><code class="name">var <span class="ident">panels</span> : list</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyramidtriangles.grid.face.Face.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>model: Model, spec: list[list[int]], start: Address = Address(universe=Universe(base=1, id=1), offset=4), rows_per_panel: int = 11) ‑> <a title="pyramidtriangles.grid.face.Face" href="#pyramidtriangles.grid.face.Face">Face</a></span>
</code></dt>
<dd>
<div class="desc"><p>Build a Face from a panel placement spec.</p>
<p>Each item the spec is a list representing a row (of panels), starting from the top.
[[], [], []]
# represents 3 empty rows</p>
<p>Adding a position to the list indicates a panel exists in that row at that position.
[[0], [], [4]]
# represents 3 rows, panel at beginning or first row and a panel at 4th spot of 3rd row.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls,
          model: Model,
          spec: list[list[int]],
          start: Address = Address(Universe(1, 1), 4),
          rows_per_panel: int = 11) -&gt; Face:
    &#34;&#34;&#34;
    Build a Face from a panel placement spec.

    Each item the spec is a list representing a row (of panels), starting from the top.
    [[], [], []]  # represents 3 empty rows

    Adding a position to the list indicates a panel exists in that row at that position.
    [[0], [], [4]]  # represents 3 rows, panel at beginning or first row and a panel at 4th spot of 3rd row.
    &#34;&#34;&#34;

    overall_geom = Geometry(origin=Coordinate(0, 0),
                            rows=(len(spec) * rows_per_panel))
    panel_rows: list[list[Panel]] = [[] for _ in range(len(spec))]
    addr = start

    # Work row-by-row, panel-by-panel, generating all panels so we can use
    # the offset of the previous to generate the next. Later, we&#39;ll filter
    # out ones missing from the spec.
    for r in reversed(range(len(spec))):
        panel_row = panel_rows[r]
        panels_in_row = (r + 1) * 2 - 1

        if r + 1 == len(panel_rows):
            origin = Coordinate(0, 0)
        else:
            leftmost_panel_in_row_below = panel_rows[r + 1][0]
            origin = leftmost_panel_in_row_below.geom.apex.adjust(+1, +1)

        for i in range(panels_in_row):
            geom = Geometry(origin=origin, rows=rows_per_panel)
            panel = Panel(geom=geom, start=addr)

            panel_row.append(panel)

            origin = origin.adjust(x=(geom.width + 1))

            if i in spec[r]:
                # if this panel is included, update the starting address
                # of the next panel
                highest_universe = max(cell.highest_universe
                                       for cell in panel.cells(overall_geom))
                next_id = highest_universe.id + 1
                universe = Universe(base=next_id, id=next_id)
                addr = Address(universe, start.offset)

    # Exclude panels that aren&#39;t in the spec
    real_panels = []
    for row_spec, row_panels in zip(spec, panel_rows):
        for i, panel in enumerate(row_panels):
            if i in row_spec:
                real_panels.append(panel)

    return Face(model, overall_geom, real_panels)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyramidtriangles.grid.face.Face.cells"><code class="name">var <span class="ident">cells</span> : list</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cells(self) -&gt; list[Cell]:
    return list(self._cells.values())</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.grid.face.Face.next_address"><code class="name">var <span class="ident">next_address</span> : <a title="pyramidtriangles.grid.geom.Address" href="geom.html#pyramidtriangles.grid.geom.Address">Address</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def next_address(self) -&gt; Address:
    lowest_addr = min(min(cell.addresses) for cell in self.cells)
    highest_universe = max(cell.highest_universe for cell in self.cells)

    next_id = highest_universe.id + 1
    return Address(Universe(next_id, next_id), lowest_addr.offset)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyramidtriangles.grid.grid.Grid" href="grid.html#pyramidtriangles.grid.grid.Grid">Grid</a></b></code>:
<ul class="hlist">
<li><code><a title="pyramidtriangles.grid.grid.Grid.go" href="grid.html#pyramidtriangles.grid.grid.Grid.go">go</a></code></li>
<li><code><a title="pyramidtriangles.grid.grid.Grid.pixels" href="grid.html#pyramidtriangles.grid.grid.Grid.pixels">pixels</a></code></li>
<li><code><a title="pyramidtriangles.grid.grid.Grid.select" href="grid.html#pyramidtriangles.grid.grid.Grid.select">select</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyramidtriangles.grid.face.Panel"><code class="flex name class">
<span>class <span class="ident">Panel</span></span>
<span>(</span><span>geom: ForwardRef('Geometry'), start: ForwardRef('Address'))</span>
</code></dt>
<dd>
<div class="desc"><p>Panel represents an assembled panel in the pyramid frame.</p>
<p>A Face contains a set of Panels. Panel isn't expected to be used often outside of that class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Panel(NamedTuple):
    &#34;&#34;&#34;
    Panel represents an assembled panel in the pyramid frame.

    A Face contains a set of Panels. Panel isn&#39;t expected to be used often outside of that class.
    &#34;&#34;&#34;

    geom: Geometry
    start: Address

    def cells(self, within: Geometry) -&gt; list[Cell]:
        &#34;&#34;&#34;
        Generate the panel&#39;s cells. `within` is the overall Face&#39;s geometry.
        &#34;&#34;&#34;

        cells = []
        addr = self.start

        for y in range(self.geom.rows):
            row_cells = self._cells_in_row(within, y, addr)
            cells.extend(row_cells)

            last_address = max(chain.from_iterable(
                cell.addresses for cell in row_cells))
            addr = last_address.next

        return cells

    def _cells_in_row(self, within: Geometry, y: int, start: Address) -&gt; list[Cell]:
        row = Coordinate(0, y).pos(self.geom).row

        cells = self._up_pointed_cells_in_row(within, row, y, start)
        last_up_address = cells[-1].addresses[-1]
        first_address_after_gap = last_up_address.range(
            PIXELS_IN_ROW_TURNAROUND)[-1]
        cells.extend(self._down_pointed_cells_in_row(
            within, row, y, first_address_after_gap))

        return cells

    def _up_pointed_cells_in_row(self, within: Geometry, row: int, y: int, start: Address) -&gt; list[Cell]:
        cells = []
        addr = start

        offset = int((self.geom.width - self.geom.row_length(row)) / 2)
        for i in range(row + 1):
            coord = Coordinate(self.geom.origin.x + offset + i * 2,
                               self.geom.origin.y + y)
            addrs = addr.range(PIXELS_PER_CELL)

            cells.append(Cell(coord, Orientation.POINT_UP,
                              addrs, within, real=True))

            addr = addrs[-1].next

        return cells

    def _down_pointed_cells_in_row(self, within: Geometry, row: int, y: int, start: Address) -&gt; list[Cell]:
        cells = []
        addr = start

        offset = int((self.geom.width - self.geom.row_length(row)) / 2)
        x = offset + self.geom.row_length(row) - 2
        for _ in range(row):
            coord = Coordinate(self.geom.origin.x + x, self.geom.origin.y + y)
            addrs = addr.range(PIXELS_PER_CELL)

            cells.append(Cell(coord, Orientation.POINT_DOWN,
                              addrs, within, real=True))

            x -= 2
            addr = addrs[-1].next

        return cells</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyramidtriangles.grid.face.Panel.geom"><code class="name">var <span class="ident">geom</span> : <a title="pyramidtriangles.grid.geom.Geometry" href="geom.html#pyramidtriangles.grid.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="pyramidtriangles.grid.face.Panel.start"><code class="name">var <span class="ident">start</span> : <a title="pyramidtriangles.grid.geom.Address" href="geom.html#pyramidtriangles.grid.geom.Address">Address</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyramidtriangles.grid.face.Panel.cells"><code class="name flex">
<span>def <span class="ident">cells</span></span>(<span>self, within: Geometry) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the panel's cells. <code>within</code> is the overall Face's geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cells(self, within: Geometry) -&gt; list[Cell]:
    &#34;&#34;&#34;
    Generate the panel&#39;s cells. `within` is the overall Face&#39;s geometry.
    &#34;&#34;&#34;

    cells = []
    addr = self.start

    for y in range(self.geom.rows):
        row_cells = self._cells_in_row(within, y, addr)
        cells.extend(row_cells)

        last_address = max(chain.from_iterable(
            cell.addresses for cell in row_cells))
        addr = last_address.next

    return cells</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyramidtriangles.grid" href="index.html">pyramidtriangles.grid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyramidtriangles.grid.face.Face" href="#pyramidtriangles.grid.face.Face">Face</a></code></h4>
<ul class="">
<li><code><a title="pyramidtriangles.grid.face.Face.build" href="#pyramidtriangles.grid.face.Face.build">build</a></code></li>
<li><code><a title="pyramidtriangles.grid.face.Face.cells" href="#pyramidtriangles.grid.face.Face.cells">cells</a></code></li>
<li><code><a title="pyramidtriangles.grid.face.Face.geom" href="#pyramidtriangles.grid.face.Face.geom">geom</a></code></li>
<li><code><a title="pyramidtriangles.grid.face.Face.next_address" href="#pyramidtriangles.grid.face.Face.next_address">next_address</a></code></li>
<li><code><a title="pyramidtriangles.grid.face.Face.panels" href="#pyramidtriangles.grid.face.Face.panels">panels</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyramidtriangles.grid.face.Panel" href="#pyramidtriangles.grid.face.Panel">Panel</a></code></h4>
<ul class="">
<li><code><a title="pyramidtriangles.grid.face.Panel.cells" href="#pyramidtriangles.grid.face.Panel.cells">cells</a></code></li>
<li><code><a title="pyramidtriangles.grid.face.Panel.geom" href="#pyramidtriangles.grid.face.Panel.geom">geom</a></code></li>
<li><code><a title="pyramidtriangles.grid.face.Panel.start" href="#pyramidtriangles.grid.face.Panel.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>